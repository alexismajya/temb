var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { ErrorHandler, Injectable } from "@angular/core";
var BugsnagErrorHandler = (function (_super) {
    __extends(BugsnagErrorHandler, _super);
    function BugsnagErrorHandler(bugsnagClient) {
        var _this = _super.call(this) || this;
        _this.bugsnagClient = bugsnagClient;
        return _this;
    }
    BugsnagErrorHandler.prototype.handleError = function (error) {
        var handledState = {
            severity: "error",
            severityReason: { type: "unhandledException" },
            unhandled: true
        };
        var report = new this.bugsnagClient.BugsnagReport(error.name, error.message, this.bugsnagClient.BugsnagReport.getStacktrace(error), handledState);
        if (error.ngDebugContext) {
            report.updateMetaData("angular", {
                component: error.ngDebugContext.component,
                context: error.ngDebugContext.context
            });
        }
        this.bugsnagClient.notify(report);
        ErrorHandler.prototype.handleError.call(this, error);
    };
    return BugsnagErrorHandler;
}(ErrorHandler));
export { BugsnagErrorHandler };
BugsnagErrorHandler.decorators = [
    { type: Injectable },
];
/** @nocollapse */
BugsnagErrorHandler.ctorParameters = function () { return [
    { type: Client },
]; };
var plugin = {
    init: function (client) {
        return new BugsnagErrorHandler(client);
    },
    name: "Angular"
};
export default plugin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxPQUFPLEVBQUUsWUFBQSxFQUFjLFVBQUEsRUFBVyxNQUFPLGVBQUEsQ0FBZ0I7QUFJekQ7SUFBeUMsdUNBQVk7SUFFbkQsNkJBQVksYUFBNkI7UUFBekMsWUFDRSxpQkFBTyxTQUVSO1FBREMsS0FBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7O0lBQ3JDLENBQUM7SUFFTSx5Q0FBVyxHQUFsQixVQUFtQixLQUFVO1FBQzNCLElBQU0sWUFBWSxHQUFHO1lBQ25CLFFBQVEsRUFBRSxPQUFPO1lBQ2pCLGNBQWMsRUFBRSxFQUFFLElBQUksRUFBRSxvQkFBb0IsRUFBRTtZQUM5QyxTQUFTLEVBQUUsSUFBSTtTQUNoQixDQUFDO1FBRUYsSUFBTSxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FDakQsS0FBSyxDQUFDLElBQUksRUFDVixLQUFLLENBQUMsT0FBTyxFQUNiLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsRUFDckQsWUFBWSxDQUNiLENBQUM7UUFFRixFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztZQUN6QixNQUFNLENBQUMsY0FBYyxDQUFDLFNBQVMsRUFBRTtnQkFDL0IsU0FBUyxFQUFFLEtBQUssQ0FBQyxjQUFjLENBQUMsU0FBUztnQkFDekMsT0FBTyxFQUFFLEtBQUssQ0FBQyxjQUFjLENBQUMsT0FBTzthQUN0QyxDQUFDLENBQUM7UUFDTCxDQUFDO1FBRUQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbEMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBUUgsMEJBQUM7QUFBRCxDQXRDQSxBQXNDQyxDQXRDd0MsWUFBWTs7QUErQjlDLDhCQUFVLEdBQTBCO0lBQzNDLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRTtDQUNuQixDQUFDO0FBQ0Ysa0JBQWtCO0FBQ1gsa0NBQWMsR0FBbUUsY0FBTSxPQUFBO0lBQzlGLEVBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRztDQUNmLEVBRjZGLENBRTdGLENBQUM7QUFHRixJQVBNLE1BQUEsR0FBMEI7SUFROUIsSUFBSSxFQVBFLFVBQUEsTUFBa0I7UUFRdEIsTUFBTSxDQVBDLElBQUksbUJBQUEsQ0FBb0IsTUFBQyxDQUFNLENBQUM7SUFRekMsQ0FBQztJQUNELElBQUksRUFQRSxTQUFBO0NBUVAsQ0FQQztBQVNGLGVBUGUsTUFBQSxDQUFPIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9iZW5nb3VybGV5L0RldmVsb3BtZW50L2J1Z3NuYWctanMvcGFja2FnZXMvcGx1Z2luLWFuZ3VsYXIvc3JjLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVycm9ySGFuZGxlciwgSW5qZWN0YWJsZSB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBCdWdzbmFnIH0gZnJvbSBcIkBidWdzbmFnL2pzXCI7XG5cblxuZXhwb3J0IGNsYXNzIEJ1Z3NuYWdFcnJvckhhbmRsZXIgZXh0ZW5kcyBFcnJvckhhbmRsZXIge1xuICBwdWJsaWMgYnVnc25hZ0NsaWVudDogQnVnc25hZy5DbGllbnQ7XG4gIGNvbnN0cnVjdG9yKGJ1Z3NuYWdDbGllbnQ6IEJ1Z3NuYWcuQ2xpZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmJ1Z3NuYWdDbGllbnQgPSBidWdzbmFnQ2xpZW50O1xuICB9XG5cbiAgcHVibGljIGhhbmRsZUVycm9yKGVycm9yOiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBoYW5kbGVkU3RhdGUgPSB7XG4gICAgICBzZXZlcml0eTogXCJlcnJvclwiLFxuICAgICAgc2V2ZXJpdHlSZWFzb246IHsgdHlwZTogXCJ1bmhhbmRsZWRFeGNlcHRpb25cIiB9LFxuICAgICAgdW5oYW5kbGVkOiB0cnVlLFxuICAgIH07XG5cbiAgICBjb25zdCByZXBvcnQgPSBuZXcgdGhpcy5idWdzbmFnQ2xpZW50LkJ1Z3NuYWdSZXBvcnQoXG4gICAgICBlcnJvci5uYW1lLFxuICAgICAgZXJyb3IubWVzc2FnZSxcbiAgICAgIHRoaXMuYnVnc25hZ0NsaWVudC5CdWdzbmFnUmVwb3J0LmdldFN0YWNrdHJhY2UoZXJyb3IpLFxuICAgICAgaGFuZGxlZFN0YXRlLFxuICAgICk7XG5cbiAgICBpZiAoZXJyb3IubmdEZWJ1Z0NvbnRleHQpIHtcbiAgICAgIHJlcG9ydC51cGRhdGVNZXRhRGF0YShcImFuZ3VsYXJcIiwge1xuICAgICAgICBjb21wb25lbnQ6IGVycm9yLm5nRGVidWdDb250ZXh0LmNvbXBvbmVudCxcbiAgICAgICAgY29udGV4dDogZXJyb3IubmdEZWJ1Z0NvbnRleHQuY29udGV4dCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuYnVnc25hZ0NsaWVudC5ub3RpZnkocmVwb3J0KTtcbiAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICB9XG5zdGF0aWMgZGVjb3JhdG9yczogRGVjb3JhdG9ySW52b2NhdGlvbltdID0gW1xueyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5zdGF0aWMgY3RvclBhcmFtZXRlcnM6ICgpID0+ICh7dHlwZTogYW55LCBkZWNvcmF0b3JzPzogRGVjb3JhdG9ySW52b2NhdGlvbltdfXxudWxsKVtdID0gKCkgPT4gW1xue3R5cGU6IENsaWVudCwgfSxcbl07XG59XG5cbmNvbnN0IHBsdWdpbjogQnVnc25hZy5JUGx1Z2luID0ge1xuICBpbml0OiAoY2xpZW50OiBCdWdzbmFnLkNsaWVudCk6IEVycm9ySGFuZGxlciA9PiB7XG4gICAgcmV0dXJuIG5ldyBCdWdzbmFnRXJyb3JIYW5kbGVyKGNsaWVudCk7XG4gIH0sXG4gIG5hbWU6IFwiQW5ndWxhclwiLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgcGx1Z2luO1xuXG5pbnRlcmZhY2UgRGVjb3JhdG9ySW52b2NhdGlvbiB7XG4gIHR5cGU6IEZ1bmN0aW9uO1xuICBhcmdzPzogYW55W107XG59XG4iXX0=